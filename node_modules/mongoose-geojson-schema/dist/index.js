"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Feature: () => Feature,
  FeatureCollection: () => FeatureCollection,
  GeoJSON: () => GeoJSON,
  Geometry: () => Geometry,
  GeometryCollection: () => GeometryCollection,
  LineString: () => LineString,
  MultiLineString: () => MultiLineString,
  MultiPoint: () => MultiPoint,
  MultiPolygon: () => MultiPolygon,
  Point: () => Point,
  Polygon: () => Polygon
});
module.exports = __toCommonJS(index_exports);
var import_mongoose = __toESM(require("mongoose"));
var { Schema } = import_mongoose.default;
var { Types } = import_mongoose.default;
var crs = void 0;
function validateCrs(crs2) {
  if (typeof crs2 !== "object" && crs2 !== null) {
    throw new import_mongoose.default.Error("Crs must be an object or null");
  }
  if (crs2 === null) {
    return;
  }
  if (!crs2.type) {
    throw new import_mongoose.default.Error("Crs must have a type");
  }
  if (crs2.type !== "name" && crs2.type !== "link") {
    throw new import_mongoose.default.Error("Crs must be either a name or link");
  }
  if (!crs2.properties) {
    throw new import_mongoose.default.Error("Crs must contain a properties object");
  }
  if (crs2.type === "name" && !crs2.properties.name) {
    throw new import_mongoose.default.Error("Crs specified by name must have a name property");
  }
  if (crs2.type === "link" && !crs2.properties.href || crs2.type === "link" && !crs2.properties.type) {
    throw new import_mongoose.default.Error(
      "Crs specified by link must have a name and href property"
    );
  }
}
var GeoJSON = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "GeoJSON");
  }
  cast(geojson) {
    if (!geojson.type) {
      throw new import_mongoose.default.Error("GeoJSON objects must have a type");
    }
    const TypeClass = import_mongoose.default.Schema.Types[geojson.type];
    if (!TypeClass) {
      throw new import_mongoose.default.Error(geojson.type + " is not a valid GeoJSON type");
    }
    return TypeClass.prototype.cast.apply(this, arguments);
  }
};
GeoJSON.schemaName = "GeoJSON";
var Point = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "Point");
  }
  cast(point) {
    if (!point.type) {
      throw new import_mongoose.default.Error("Point must have a type");
    }
    if (point.type !== "Point") {
      throw new import_mongoose.default.Error(point.type + " is not a valid GeoJSON type");
    }
    if (point.crs) {
      crs = point.crs;
      validateCrs(crs);
    } else {
      crs = void 0;
    }
    validatePoint(point.coordinates);
    return point;
  }
};
Point.schemaName = "Point";
function validatePoint(coordinates) {
  if (typeof coordinates !== "object") {
    throw new import_mongoose.default.Error("Point " + coordinates + " must be an array");
  }
  if (coordinates.length < 2 || coordinates.length > 3) {
    throw new import_mongoose.default.Error(
      "Point" + coordinates + " must contain two or three coordinates"
    );
  }
  if (isNaN(coordinates[0]) || isNaN(coordinates[1])) {
    throw new import_mongoose.default.Error("Point must have real numbers");
  }
  if (typeof coordinates[0] !== "number" || typeof coordinates[1] !== "number") {
    throw new import_mongoose.default.Error("Point must have two numbers");
  }
  if (!crs) {
    if (coordinates[0] > 180 || coordinates[0] < -180) {
      throw new import_mongoose.default.Error(
        "Point" + coordinates[0] + " should be within the boundaries of longitude"
      );
    }
    if (coordinates[1] > 90 || coordinates[1] < -90) {
      throw new import_mongoose.default.Error(
        "Point" + coordinates[1] + " should be within the boundaries of latitude"
      );
    }
  }
}
var MultiPoint = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "MultiPoint");
  }
  cast(multipoint) {
    if (typeof multipoint.coordinates !== "object") {
      throw new import_mongoose.default.Error("MultiPoint must be an array");
    }
    if (!multipoint.type) {
      throw new import_mongoose.default.Error("MultiPoint must have a type");
    }
    if (multipoint.type !== "MultiPoint") {
      throw new import_mongoose.default.Error(multipoint.type + " is not a valid GeoJSON type");
    }
    if (multipoint.crs) {
      crs = multipoint.crs;
      validateCrs(crs);
    }
    validateMultiPoint(multipoint.coordinates);
    return multipoint;
  }
};
MultiPoint.schemaName = "MultiPoint";
function validateMultiPoint(coordinates) {
  for (let i = 0; i < coordinates.length; i++) {
    validatePoint(coordinates[i]);
  }
}
var LineString = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "LineString");
  }
  cast(linestring) {
    if (!linestring.type) {
      throw new import_mongoose.default.Error("LineString must have a type");
    }
    if (linestring.type !== "LineString") {
      throw new import_mongoose.default.Error(linestring.type + " is not a valid GeoJSON type");
    }
    if (linestring.coordinates.length < 2) {
      throw new import_mongoose.default.Error("LineString type must have at least two Points");
    }
    if (linestring.crs) {
      crs = linestring.crs;
      validateCrs(crs);
    }
    validateLineString(linestring.coordinates);
    return linestring;
  }
};
LineString.schemaName = "LineString";
function validateLineString(coordinates) {
  for (let i = 0; i < coordinates.length; i++) {
    validatePoint(coordinates[i]);
  }
}
var MultiLineString = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "MultiLineString");
  }
  cast(multilinestring) {
    if (typeof multilinestring.coordinates !== "object") {
      throw new import_mongoose.default.Error("MultiLineString must be an array");
    }
    if (!multilinestring.type) {
      throw new import_mongoose.default.Error("MultiLineString must have a type");
    }
    if (multilinestring.type !== "MultiLineString") {
      throw new import_mongoose.default.Error(
        multilinestring.type + " is not a valid GeoJSON type"
      );
    }
    validateMultiLineString(multilinestring.coordinates);
    return multilinestring;
  }
};
MultiLineString.schemaName = "MultiLineString";
function validateMultiLineString(coordinates) {
  for (let i = 0; i < coordinates.length; i++) {
    validateLineString(coordinates[i]);
  }
}
var Polygon = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "Polygon");
  }
  cast(polygon) {
    if (!polygon.type) {
      throw new import_mongoose.default.Error("Polygon must have a type");
    }
    if (polygon.type !== "Polygon") {
      throw new import_mongoose.default.Error(polygon.type + " is not a valid GeoJSON type");
    }
    if (polygon.crs) {
      crs = polygon.crs;
      validateCrs(crs);
    }
    validatePolygon(polygon.coordinates);
    return polygon;
  }
};
Polygon.schemaName = "Polygon";
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;
  for (let i = arr1.length; i--; ) {
    if (arr1[i] !== arr2[i]) return false;
  }
  return true;
}
function validatePolygon(coordinates) {
  for (let i = 0; i < coordinates.length; i++) {
    if (coordinates[i].length < 4) {
      throw new import_mongoose.default.Error(
        "Each Polygon LinearRing must have at least four elements"
      );
    }
    if (!arraysEqual(coordinates[i][0], coordinates[i][coordinates[i].length - 1])) {
      throw new import_mongoose.default.Error(
        "Each Polygon LinearRing must have an identical first and last point"
      );
    }
    validateLineString(coordinates[i]);
  }
}
var MultiPolygon = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "MultiPolygon");
  }
  cast(multipolygon) {
    if (typeof multipolygon.coordinates !== "object") {
      throw new import_mongoose.default.Error("MultiPolygon must be an array");
    }
    if (!multipolygon.type) {
      throw new import_mongoose.default.Error("MultiPolygon must have a type");
    }
    if (multipolygon.type !== "MultiPolygon") {
      throw new import_mongoose.default.Error(multipolygon.type + " is not a valid GeoJSON type");
    }
    if (multipolygon.crs) {
      crs = multipolygon.crs;
      validateCrs(crs);
    }
    validateMultiPolygon(multipolygon.coordinates);
    return multipolygon;
  }
};
MultiPolygon.schemaName = "MultiPolygon";
function validateMultiPolygon(coordinates) {
  for (let i = 0; i < coordinates.length; i++) {
    validatePolygon(coordinates[i]);
  }
}
var Geometry = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "Geometry");
  }
  cast(geometry) {
    if (!geometry.type) {
      throw new import_mongoose.default.Error("Geometry must must have a type");
    }
    if (geometry.crs) {
      crs = geometry.crs;
      validateCrs(crs);
    }
    validateGeometry(geometry);
    return geometry;
  }
};
Geometry.schemaName = "Geometry";
function validateGeometry(geometry) {
  switch (geometry.type) {
    case "Point":
      validatePoint(geometry.coordinates);
      break;
    case "MultiPoint":
      validateMultiPoint(geometry.coordinates);
      break;
    case "LineString":
      validateLineString(geometry.coordinates);
      break;
    case "MultiLineString":
      validateMultiLineString(geometry.coordinates);
      break;
    case "Polygon":
      validatePolygon(geometry.coordinates);
      break;
    case "MultiPolygon":
      validateMultiPolygon(geometry.coordinates);
      break;
    default:
      throw new import_mongoose.default.Error("Geometry must have a valid type");
  }
}
var GeometryCollection = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "GeometryCollection");
  }
  cast(geometrycollection) {
    if (typeof geometrycollection.geometries !== "object") {
      throw new import_mongoose.default.Error("GeometryCollection must be an array");
    }
    if (geometrycollection.crs) {
      crs = geometrycollection.crs;
      validateCrs(crs);
    }
    validateGeometries(geometrycollection.geometries);
    return geometrycollection;
  }
};
GeometryCollection.schemaName = "GeometryCollection";
function validateGeometries(geometries) {
  for (let i = 0; i < geometries.length; i++) {
    validateGeometry(geometries[i]);
  }
}
var Feature = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "Feature");
  }
  cast(feature) {
    validateFeature(feature);
    return feature;
  }
};
Feature.schemaName = "Feature";
function validateFeature(feature) {
  if (!feature.type) {
    throw new import_mongoose.default.Error("Feature must have a type");
  }
  if (feature.type !== "Feature") {
    throw new import_mongoose.default.Error(feature.type + " is not a valid GeoJSON type");
  }
  if (!feature.geometry) {
    throw new import_mongoose.default.Error("Feature must have a geometry");
  }
  if (feature.crs) {
    crs = feature.crs;
    validateCrs(crs);
  }
  validateGeometry(feature.geometry);
}
var FeatureCollection = class extends import_mongoose.default.SchemaType {
  constructor(key, options) {
    super(key, options, "FeatureCollection");
  }
  cast(featurecollection) {
    if (!featurecollection.type) {
      throw new import_mongoose.default.Error("FeatureCollection must have a type");
    }
    if (featurecollection.type !== "FeatureCollection") {
      throw new import_mongoose.default.Error(
        featurecollection.type + " is not a valid GeoJSON type"
      );
    }
    if (!featurecollection.features) {
      throw new import_mongoose.default.Error("FeatureCollections must have a features object");
    }
    if (featurecollection.crs) {
      crs = featurecollection.crs;
      validateCrs(crs);
    }
    validateFeatureCollection(featurecollection);
    return featurecollection;
  }
};
FeatureCollection.schemaName = "FeatureCollection";
function validateFeatureCollection(featurecollection) {
  for (let i = 0; i < featurecollection.features.length; i++) {
    validateFeature(featurecollection.features[i]);
  }
  return featurecollection;
}
Schema.Types.Feature = Feature;
Schema.Types.FeatureCollection = FeatureCollection;
Schema.Types.GeoJSON = GeoJSON;
Schema.Types.Geometry = Geometry;
Schema.Types.GeometryCollection = GeometryCollection;
Schema.Types.LineString = LineString;
Schema.Types.MultiLineString = MultiLineString;
Schema.Types.MultiPoint = MultiPoint;
Schema.Types.MultiPolygon = MultiPolygon;
Schema.Types.Point = Point;
Schema.Types.Polygon = Polygon;
Types.Feature = Feature;
Types.FeatureCollection = FeatureCollection;
Types.GeoJSON = GeoJSON;
Types.Geometry = Geometry;
Types.GeometryCollection = GeometryCollection;
Types.LineString = LineString;
Types.MultiLineString = MultiLineString;
Types.MultiPoint = MultiPoint;
Types.MultiPolygon = MultiPolygon;
Types.Point = Point;
Types.Polygon = Polygon;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Feature,
  FeatureCollection,
  GeoJSON,
  Geometry,
  GeometryCollection,
  LineString,
  MultiLineString,
  MultiPoint,
  MultiPolygon,
  Point,
  Polygon
});
//# sourceMappingURL=index.js.map