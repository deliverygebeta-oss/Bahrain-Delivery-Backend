{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * GeoJSON Schemas for Mongoose\n *\n * rough GeoJSON schemas for use with mongoose schema creation\n *\n * Based on GeoJSON Spec @ http://geojson.org/geojson-spec.html\n *\n * Created by Ben Dalton (ben@rideamigos) on 3/27/14.\n * Copyright RideAmigos (http://rideamigos.com)\n * Updates and maintenance by Josh Kopecek (josh@echoes.xyz)\n *\n * */\n\nimport mongoose from 'mongoose';\nimport {\n  GeoJSON as GeoJSONType,\n  Point as PointType,\n  MultiPoint as MultiPointType,\n  LineString as LineStringType,\n  MultiLineString as MultiLineStringType,\n  Polygon as PolygonType,\n  MultiPolygon as MultiPolygonType,\n  Geometry as GeometryType,\n  GeometryCollection as GeometryCollectionType,\n  Feature as FeatureType,\n  FeatureCollection as FeatureCollectionType,\n  Position\n} from 'geojson';\n\nconst { Schema } = mongoose;\nconst { Types } = mongoose;\n\ninterface CRS {\n  type: 'name' | 'link';\n  properties: {\n    name?: string;\n    href?: string;\n    type?: string;\n  };\n}\n\nlet crs: CRS | null | undefined = undefined;\n\nfunction validateCrs(crs: CRS | null | undefined): void {\n  if (typeof crs !== 'object' && crs !== null) {\n    throw new mongoose.Error('Crs must be an object or null');\n  }\n  if (crs === null) {\n    return;\n  }\n  if (!crs.type) {\n    throw new mongoose.Error('Crs must have a type');\n  }\n  if (crs.type !== 'name' && crs.type !== 'link') {\n    throw new mongoose.Error('Crs must be either a name or link');\n  }\n  if (!crs.properties) {\n    throw new mongoose.Error('Crs must contain a properties object');\n  }\n  if (crs.type === 'name' && !crs.properties.name) {\n    throw new mongoose.Error('Crs specified by name must have a name property');\n  }\n  if (\n    (crs.type === 'link' && !crs.properties.href) ||\n    (crs.type === 'link' && !crs.properties.type)\n  ) {\n    throw new mongoose.Error(\n      'Crs specified by link must have a name and href property'\n    );\n  }\n}\n\nclass GeoJSON extends mongoose.SchemaType {\n  static schemaName = 'GeoJSON';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'GeoJSON');\n  }\n\n  cast(geojson: any): GeoJSONType {\n    if (!geojson.type) {\n      throw new mongoose.Error('GeoJSON objects must have a type');\n    }\n\n    const TypeClass = (mongoose.Schema.Types as any)[geojson.type];\n    if (!TypeClass) {\n      throw new mongoose.Error(geojson.type + ' is not a valid GeoJSON type');\n    }\n\n    return TypeClass.prototype.cast.apply(this, arguments);\n  }\n}\n\nclass Point extends mongoose.SchemaType {\n  static schemaName = 'Point';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'Point');\n  }\n\n  cast(point: any): PointType {\n    if (!point.type) {\n      throw new mongoose.Error('Point must have a type');\n    }\n    // type must be Point\n    if (point.type !== 'Point') {\n      throw new mongoose.Error(point.type + ' is not a valid GeoJSON type');\n    }\n    // check for crs\n    if (point.crs) {\n      crs = point.crs;\n      validateCrs(crs);\n    } else {\n      crs = undefined;\n    }\n    validatePoint(point.coordinates);\n    return point;\n  }\n}\n\nfunction validatePoint(coordinates: Position): void {\n  // must be an array (object)\n  if (typeof coordinates !== 'object') {\n    throw new mongoose.Error('Point ' + coordinates + ' must be an array');\n  }\n  // must have 2/3 points\n  if (coordinates.length < 2 || coordinates.length > 3) {\n    throw new mongoose.Error(\n      'Point' + coordinates + ' must contain two or three coordinates'\n    );\n  }\n  // must have real numbers\n  if (isNaN(coordinates[0]) || isNaN(coordinates[1])) {\n    throw new mongoose.Error('Point must have real numbers');\n  }\n  // must have two numbers\n  if (\n    typeof coordinates[0] !== 'number' ||\n    typeof coordinates[1] !== 'number'\n  ) {\n    throw new mongoose.Error('Point must have two numbers');\n  }\n  if (!crs) {\n    // longitude must be within bounds\n    if (coordinates[0] > 180 || coordinates[0] < -180) {\n      throw new mongoose.Error(\n        'Point' +\n          coordinates[0] +\n          ' should be within the boundaries of longitude'\n      );\n    }\n    // latitude must be within bounds\n    if (coordinates[1] > 90 || coordinates[1] < -90) {\n      throw new mongoose.Error(\n        'Point' +\n          coordinates[1] +\n          ' should be within the boundaries of latitude'\n      );\n    }\n  }\n}\n\nclass MultiPoint extends mongoose.SchemaType {\n  static schemaName = 'MultiPoint';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'MultiPoint');\n  }\n\n  cast(multipoint: any): MultiPointType {\n    // must be an array (object)\n    if (typeof multipoint.coordinates !== 'object') {\n      throw new mongoose.Error('MultiPoint must be an array');\n    }\n    if (!multipoint.type) {\n      throw new mongoose.Error('MultiPoint must have a type');\n    }\n    // type must be MultiPoint\n    if (multipoint.type !== 'MultiPoint') {\n      throw new mongoose.Error(multipoint.type + ' is not a valid GeoJSON type');\n    }\n    // check for crs\n    if (multipoint.crs) {\n      crs = multipoint.crs;\n      validateCrs(crs);\n    }\n    validateMultiPoint(multipoint.coordinates);\n    return multipoint;\n  }\n}\n\nfunction validateMultiPoint(coordinates: Position[]): void {\n  for (let i = 0; i < coordinates.length; i++) {\n    validatePoint(coordinates[i]);\n  }\n}\n\nclass LineString extends mongoose.SchemaType {\n  static schemaName = 'LineString';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'LineString');\n  }\n\n  cast(linestring: any): LineStringType {\n    if (!linestring.type) {\n      throw new mongoose.Error('LineString must have a type');\n    }\n    // type must be LineString\n    if (linestring.type !== 'LineString') {\n      throw new mongoose.Error(linestring.type + ' is not a valid GeoJSON type');\n    }\n    // must have at least two Points\n    if (linestring.coordinates.length < 2) {\n      throw new mongoose.Error('LineString type must have at least two Points');\n    }\n    // check for crs\n    if (linestring.crs) {\n      crs = linestring.crs;\n      validateCrs(crs);\n    }\n    validateLineString(linestring.coordinates);\n    return linestring;\n  }\n}\n\nfunction validateLineString(coordinates: Position[]): void {\n  for (let i = 0; i < coordinates.length; i++) {\n    validatePoint(coordinates[i]);\n  }\n}\n\nclass MultiLineString extends mongoose.SchemaType {\n  static schemaName = 'MultiLineString';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'MultiLineString');\n  }\n\n  cast(multilinestring: any): MultiLineStringType {\n    // must be an array (object)\n    if (typeof multilinestring.coordinates !== 'object') {\n      throw new mongoose.Error('MultiLineString must be an array');\n    }\n    if (!multilinestring.type) {\n      throw new mongoose.Error('MultiLineString must have a type');\n    }\n    // type must be MultiLineString\n    if (multilinestring.type !== 'MultiLineString') {\n      throw new mongoose.Error(\n        multilinestring.type + ' is not a valid GeoJSON type'\n      );\n    }\n    validateMultiLineString(multilinestring.coordinates);\n    return multilinestring;\n  }\n}\n\nfunction validateMultiLineString(coordinates: Position[][]): void {\n  for (let i = 0; i < coordinates.length; i++) {\n    validateLineString(coordinates[i]);\n  }\n}\n\nclass Polygon extends mongoose.SchemaType {\n  static schemaName = 'Polygon';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'Polygon');\n  }\n\n  cast(polygon: any): PolygonType {\n    if (!polygon.type) {\n      throw new mongoose.Error('Polygon must have a type');\n    }\n    // type must be Polygon\n    if (polygon.type !== 'Polygon') {\n      throw new mongoose.Error(polygon.type + ' is not a valid GeoJSON type');\n    }\n    // check for crs\n    if (polygon.crs) {\n      crs = polygon.crs;\n      validateCrs(crs);\n    }\n    validatePolygon(polygon.coordinates);\n    return polygon;\n  }\n}\n\nfunction arraysEqual(arr1: Position, arr2: Position): boolean {\n  if (arr1.length !== arr2.length) return false;\n  for (let i = arr1.length; i--; ) {\n    if (arr1[i] !== arr2[i]) return false;\n  }\n  return true;\n}\n\nfunction validatePolygon(coordinates: Position[][]): void {\n  for (let i = 0; i < coordinates.length; i++) {\n    // The LinearRing elements must have at least four Points\n    if (coordinates[i].length < 4) {\n      throw new mongoose.Error(\n        'Each Polygon LinearRing must have at least four elements'\n      );\n    }\n    // the LinearRing objects must have identical start and end values\n    if (\n      !arraysEqual(coordinates[i][0], coordinates[i][coordinates[i].length - 1])\n    ) {\n      throw new mongoose.Error(\n        'Each Polygon LinearRing must have an identical first and last point'\n      );\n    }\n    // otherwise the LinearRings must correspond to a LineString\n    validateLineString(coordinates[i]);\n  }\n}\n\nclass MultiPolygon extends mongoose.SchemaType {\n  static schemaName = 'MultiPolygon';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'MultiPolygon');\n  }\n\n  cast(multipolygon: any): MultiPolygonType {\n    // must be an array (object)\n    if (typeof multipolygon.coordinates !== 'object') {\n      throw new mongoose.Error('MultiPolygon must be an array');\n    }\n    if (!multipolygon.type) {\n      throw new mongoose.Error('MultiPolygon must have a type');\n    }\n    // type must be Polygon\n    if (multipolygon.type !== 'MultiPolygon') {\n      throw new mongoose.Error(multipolygon.type + ' is not a valid GeoJSON type');\n    }\n    // check for crs\n    if (multipolygon.crs) {\n      crs = multipolygon.crs;\n      validateCrs(crs);\n    }\n    validateMultiPolygon(multipolygon.coordinates);\n    return multipolygon;\n  }\n}\n\nfunction validateMultiPolygon(coordinates: Position[][][]): void {\n  for (let i = 0; i < coordinates.length; i++) {\n    validatePolygon(coordinates[i]);\n  }\n}\n\nclass Geometry extends mongoose.SchemaType {\n  static schemaName = 'Geometry';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'Geometry');\n  }\n\n  cast(geometry: any): GeometryType {\n    // must be an array (object)\n    if (!geometry.type) {\n      throw new mongoose.Error('Geometry must must have a type');\n    }\n    // check for crs\n    if (geometry.crs) {\n      crs = geometry.crs;\n      validateCrs(crs);\n    }\n    validateGeometry(geometry);\n    return geometry;\n  }\n}\n\nfunction validateGeometry(geometry: GeometryType): void {\n  switch (geometry.type) {\n    case 'Point':\n      validatePoint(geometry.coordinates);\n      break;\n    case 'MultiPoint':\n      validateMultiPoint(geometry.coordinates);\n      break;\n    case 'LineString':\n      validateLineString(geometry.coordinates);\n      break;\n    case 'MultiLineString':\n      validateMultiLineString(geometry.coordinates);\n      break;\n    case 'Polygon':\n      validatePolygon(geometry.coordinates);\n      break;\n    case 'MultiPolygon':\n      validateMultiPolygon(geometry.coordinates);\n      break;\n    default:\n      throw new mongoose.Error('Geometry must have a valid type');\n  }\n}\n\nclass GeometryCollection extends mongoose.SchemaType {\n  static schemaName = 'GeometryCollection';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'GeometryCollection');\n  }\n\n  cast(geometrycollection: any): GeometryCollectionType {\n    // must be an array (object)\n    if (typeof geometrycollection.geometries !== 'object') {\n      throw new mongoose.Error('GeometryCollection must be an array');\n    }\n    // check for crs\n    if (geometrycollection.crs) {\n      crs = geometrycollection.crs;\n      validateCrs(crs);\n    }\n    validateGeometries(geometrycollection.geometries);\n    return geometrycollection;\n  }\n}\n\nfunction validateGeometries(geometries: GeometryType[]): void {\n  for (let i = 0; i < geometries.length; i++) {\n    validateGeometry(geometries[i]);\n  }\n}\n\nclass Feature extends mongoose.SchemaType {\n  static schemaName = 'Feature';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'Feature');\n  }\n\n  cast(feature: any): FeatureType {\n    validateFeature(feature);\n    return feature;\n  }\n}\n\nfunction validateFeature(feature: FeatureType): void {\n  if (!feature.type) {\n    throw new mongoose.Error('Feature must have a type');\n  }\n  // type must be Feature\n  if (feature.type !== 'Feature') {\n    throw new mongoose.Error(feature.type + ' is not a valid GeoJSON type');\n  }\n  if (!feature.geometry) {\n    throw new mongoose.Error('Feature must have a geometry');\n  }\n  // check for crs\n  if ((feature as any).crs) {\n    crs = (feature as any).crs;\n    validateCrs(crs);\n  }\n  validateGeometry(feature.geometry!);\n}\n\nclass FeatureCollection extends mongoose.SchemaType {\n  static schemaName = 'FeatureCollection';\n\n  constructor(key: string, options?: any) {\n    super(key, options, 'FeatureCollection');\n  }\n\n  cast(featurecollection: any): FeatureCollectionType {\n    if (!featurecollection.type) {\n      throw new mongoose.Error('FeatureCollection must have a type');\n    }\n    // type must be Polygon\n    if (featurecollection.type !== 'FeatureCollection') {\n      throw new mongoose.Error(\n        featurecollection.type + ' is not a valid GeoJSON type'\n      );\n    }\n    if (!featurecollection.features) {\n      throw new mongoose.Error('FeatureCollections must have a features object');\n    }\n    // check for crs\n    if (featurecollection.crs) {\n      crs = featurecollection.crs;\n      validateCrs(crs);\n    }\n    validateFeatureCollection(featurecollection);\n    return featurecollection;\n  }\n}\n\nfunction validateFeatureCollection(featurecollection: FeatureCollectionType): FeatureCollectionType {\n  for (let i = 0; i < featurecollection.features.length; i++) {\n    validateFeature(featurecollection.features[i]);\n  }\n  return featurecollection;\n}\n\n// Register the types to Schema.Types\n(Schema.Types as any).Feature = Feature;\n(Schema.Types as any).FeatureCollection = FeatureCollection;\n(Schema.Types as any).GeoJSON = GeoJSON;\n(Schema.Types as any).Geometry = Geometry;\n(Schema.Types as any).GeometryCollection = GeometryCollection;\n(Schema.Types as any).LineString = LineString;\n(Schema.Types as any).MultiLineString = MultiLineString;\n(Schema.Types as any).MultiPoint = MultiPoint;\n(Schema.Types as any).MultiPolygon = MultiPolygon;\n(Schema.Types as any).Point = Point;\n(Schema.Types as any).Polygon = Polygon;\n\n// Register the types to mongoose.Types\n(Types as any).Feature = Feature;\n(Types as any).FeatureCollection = FeatureCollection;\n(Types as any).GeoJSON = GeoJSON;\n(Types as any).Geometry = Geometry;\n(Types as any).GeometryCollection = GeometryCollection;\n(Types as any).LineString = LineString;\n(Types as any).MultiLineString = MultiLineString;\n(Types as any).MultiPoint = MultiPoint;\n(Types as any).MultiPolygon = MultiPolygon;\n(Types as any).Point = Point;\n(Types as any).Polygon = Polygon;\n\n// Export the classes for direct usage\nexport {\n  GeoJSON,\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon,\n  Geometry,\n  GeometryCollection,\n  Feature,\n  FeatureCollection\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA,sBAAqB;AAgBrB,IAAM,EAAE,OAAO,IAAI,gBAAAA;AACnB,IAAM,EAAE,MAAM,IAAI,gBAAAA;AAWlB,IAAI,MAA8B;AAElC,SAAS,YAAYC,MAAmC;AACtD,MAAI,OAAOA,SAAQ,YAAYA,SAAQ,MAAM;AAC3C,UAAM,IAAI,gBAAAD,QAAS,MAAM,+BAA+B;AAAA,EAC1D;AACA,MAAIC,SAAQ,MAAM;AAChB;AAAA,EACF;AACA,MAAI,CAACA,KAAI,MAAM;AACb,UAAM,IAAI,gBAAAD,QAAS,MAAM,sBAAsB;AAAA,EACjD;AACA,MAAIC,KAAI,SAAS,UAAUA,KAAI,SAAS,QAAQ;AAC9C,UAAM,IAAI,gBAAAD,QAAS,MAAM,mCAAmC;AAAA,EAC9D;AACA,MAAI,CAACC,KAAI,YAAY;AACnB,UAAM,IAAI,gBAAAD,QAAS,MAAM,sCAAsC;AAAA,EACjE;AACA,MAAIC,KAAI,SAAS,UAAU,CAACA,KAAI,WAAW,MAAM;AAC/C,UAAM,IAAI,gBAAAD,QAAS,MAAM,iDAAiD;AAAA,EAC5E;AACA,MACGC,KAAI,SAAS,UAAU,CAACA,KAAI,WAAW,QACvCA,KAAI,SAAS,UAAU,CAACA,KAAI,WAAW,MACxC;AACA,UAAM,IAAI,gBAAAD,QAAS;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,UAAN,cAAsB,gBAAAA,QAAS,WAAW;AAAA,EAGxC,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,SAAS;AAAA,EAC/B;AAAA,EAEA,KAAK,SAA2B;AAC9B,QAAI,CAAC,QAAQ,MAAM;AACjB,YAAM,IAAI,gBAAAA,QAAS,MAAM,kCAAkC;AAAA,IAC7D;AAEA,UAAM,YAAa,gBAAAA,QAAS,OAAO,MAAc,QAAQ,IAAI;AAC7D,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,gBAAAA,QAAS,MAAM,QAAQ,OAAO,8BAA8B;AAAA,IACxE;AAEA,WAAO,UAAU,UAAU,KAAK,MAAM,MAAM,SAAS;AAAA,EACvD;AACF;AAnBM,QACG,aAAa;AAoBtB,IAAM,QAAN,cAAoB,gBAAAA,QAAS,WAAW;AAAA,EAGtC,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,OAAO;AAAA,EAC7B;AAAA,EAEA,KAAK,OAAuB;AAC1B,QAAI,CAAC,MAAM,MAAM;AACf,YAAM,IAAI,gBAAAA,QAAS,MAAM,wBAAwB;AAAA,IACnD;AAEA,QAAI,MAAM,SAAS,SAAS;AAC1B,YAAM,IAAI,gBAAAA,QAAS,MAAM,MAAM,OAAO,8BAA8B;AAAA,IACtE;AAEA,QAAI,MAAM,KAAK;AACb,YAAM,MAAM;AACZ,kBAAY,GAAG;AAAA,IACjB,OAAO;AACL,YAAM;AAAA,IACR;AACA,kBAAc,MAAM,WAAW;AAC/B,WAAO;AAAA,EACT;AACF;AAzBM,MACG,aAAa;AA0BtB,SAAS,cAAc,aAA6B;AAElD,MAAI,OAAO,gBAAgB,UAAU;AACnC,UAAM,IAAI,gBAAAA,QAAS,MAAM,WAAW,cAAc,mBAAmB;AAAA,EACvE;AAEA,MAAI,YAAY,SAAS,KAAK,YAAY,SAAS,GAAG;AACpD,UAAM,IAAI,gBAAAA,QAAS;AAAA,MACjB,UAAU,cAAc;AAAA,IAC1B;AAAA,EACF;AAEA,MAAI,MAAM,YAAY,CAAC,CAAC,KAAK,MAAM,YAAY,CAAC,CAAC,GAAG;AAClD,UAAM,IAAI,gBAAAA,QAAS,MAAM,8BAA8B;AAAA,EACzD;AAEA,MACE,OAAO,YAAY,CAAC,MAAM,YAC1B,OAAO,YAAY,CAAC,MAAM,UAC1B;AACA,UAAM,IAAI,gBAAAA,QAAS,MAAM,6BAA6B;AAAA,EACxD;AACA,MAAI,CAAC,KAAK;AAER,QAAI,YAAY,CAAC,IAAI,OAAO,YAAY,CAAC,IAAI,MAAM;AACjD,YAAM,IAAI,gBAAAA,QAAS;AAAA,QACjB,UACE,YAAY,CAAC,IACb;AAAA,MACJ;AAAA,IACF;AAEA,QAAI,YAAY,CAAC,IAAI,MAAM,YAAY,CAAC,IAAI,KAAK;AAC/C,YAAM,IAAI,gBAAAA,QAAS;AAAA,QACjB,UACE,YAAY,CAAC,IACb;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,aAAN,cAAyB,gBAAAA,QAAS,WAAW;AAAA,EAG3C,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,YAAY;AAAA,EAClC;AAAA,EAEA,KAAK,YAAiC;AAEpC,QAAI,OAAO,WAAW,gBAAgB,UAAU;AAC9C,YAAM,IAAI,gBAAAA,QAAS,MAAM,6BAA6B;AAAA,IACxD;AACA,QAAI,CAAC,WAAW,MAAM;AACpB,YAAM,IAAI,gBAAAA,QAAS,MAAM,6BAA6B;AAAA,IACxD;AAEA,QAAI,WAAW,SAAS,cAAc;AACpC,YAAM,IAAI,gBAAAA,QAAS,MAAM,WAAW,OAAO,8BAA8B;AAAA,IAC3E;AAEA,QAAI,WAAW,KAAK;AAClB,YAAM,WAAW;AACjB,kBAAY,GAAG;AAAA,IACjB;AACA,uBAAmB,WAAW,WAAW;AACzC,WAAO;AAAA,EACT;AACF;AA3BM,WACG,aAAa;AA4BtB,SAAS,mBAAmB,aAA+B;AACzD,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,kBAAc,YAAY,CAAC,CAAC;AAAA,EAC9B;AACF;AAEA,IAAM,aAAN,cAAyB,gBAAAA,QAAS,WAAW;AAAA,EAG3C,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,YAAY;AAAA,EAClC;AAAA,EAEA,KAAK,YAAiC;AACpC,QAAI,CAAC,WAAW,MAAM;AACpB,YAAM,IAAI,gBAAAA,QAAS,MAAM,6BAA6B;AAAA,IACxD;AAEA,QAAI,WAAW,SAAS,cAAc;AACpC,YAAM,IAAI,gBAAAA,QAAS,MAAM,WAAW,OAAO,8BAA8B;AAAA,IAC3E;AAEA,QAAI,WAAW,YAAY,SAAS,GAAG;AACrC,YAAM,IAAI,gBAAAA,QAAS,MAAM,+CAA+C;AAAA,IAC1E;AAEA,QAAI,WAAW,KAAK;AAClB,YAAM,WAAW;AACjB,kBAAY,GAAG;AAAA,IACjB;AACA,uBAAmB,WAAW,WAAW;AACzC,WAAO;AAAA,EACT;AACF;AA3BM,WACG,aAAa;AA4BtB,SAAS,mBAAmB,aAA+B;AACzD,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,kBAAc,YAAY,CAAC,CAAC;AAAA,EAC9B;AACF;AAEA,IAAM,kBAAN,cAA8B,gBAAAA,QAAS,WAAW;AAAA,EAGhD,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,iBAAiB;AAAA,EACvC;AAAA,EAEA,KAAK,iBAA2C;AAE9C,QAAI,OAAO,gBAAgB,gBAAgB,UAAU;AACnD,YAAM,IAAI,gBAAAA,QAAS,MAAM,kCAAkC;AAAA,IAC7D;AACA,QAAI,CAAC,gBAAgB,MAAM;AACzB,YAAM,IAAI,gBAAAA,QAAS,MAAM,kCAAkC;AAAA,IAC7D;AAEA,QAAI,gBAAgB,SAAS,mBAAmB;AAC9C,YAAM,IAAI,gBAAAA,QAAS;AAAA,QACjB,gBAAgB,OAAO;AAAA,MACzB;AAAA,IACF;AACA,4BAAwB,gBAAgB,WAAW;AACnD,WAAO;AAAA,EACT;AACF;AAxBM,gBACG,aAAa;AAyBtB,SAAS,wBAAwB,aAAiC;AAChE,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,uBAAmB,YAAY,CAAC,CAAC;AAAA,EACnC;AACF;AAEA,IAAM,UAAN,cAAsB,gBAAAA,QAAS,WAAW;AAAA,EAGxC,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,SAAS;AAAA,EAC/B;AAAA,EAEA,KAAK,SAA2B;AAC9B,QAAI,CAAC,QAAQ,MAAM;AACjB,YAAM,IAAI,gBAAAA,QAAS,MAAM,0BAA0B;AAAA,IACrD;AAEA,QAAI,QAAQ,SAAS,WAAW;AAC9B,YAAM,IAAI,gBAAAA,QAAS,MAAM,QAAQ,OAAO,8BAA8B;AAAA,IACxE;AAEA,QAAI,QAAQ,KAAK;AACf,YAAM,QAAQ;AACd,kBAAY,GAAG;AAAA,IACjB;AACA,oBAAgB,QAAQ,WAAW;AACnC,WAAO;AAAA,EACT;AACF;AAvBM,QACG,aAAa;AAwBtB,SAAS,YAAY,MAAgB,MAAyB;AAC5D,MAAI,KAAK,WAAW,KAAK,OAAQ,QAAO;AACxC,WAAS,IAAI,KAAK,QAAQ,OAAO;AAC/B,QAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAG,QAAO;AAAA,EAClC;AACA,SAAO;AACT;AAEA,SAAS,gBAAgB,aAAiC;AACxD,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAE3C,QAAI,YAAY,CAAC,EAAE,SAAS,GAAG;AAC7B,YAAM,IAAI,gBAAAA,QAAS;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAEA,QACE,CAAC,YAAY,YAAY,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,EAAE,YAAY,CAAC,EAAE,SAAS,CAAC,CAAC,GACzE;AACA,YAAM,IAAI,gBAAAA,QAAS;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAEA,uBAAmB,YAAY,CAAC,CAAC;AAAA,EACnC;AACF;AAEA,IAAM,eAAN,cAA2B,gBAAAA,QAAS,WAAW;AAAA,EAG7C,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,cAAc;AAAA,EACpC;AAAA,EAEA,KAAK,cAAqC;AAExC,QAAI,OAAO,aAAa,gBAAgB,UAAU;AAChD,YAAM,IAAI,gBAAAA,QAAS,MAAM,+BAA+B;AAAA,IAC1D;AACA,QAAI,CAAC,aAAa,MAAM;AACtB,YAAM,IAAI,gBAAAA,QAAS,MAAM,+BAA+B;AAAA,IAC1D;AAEA,QAAI,aAAa,SAAS,gBAAgB;AACxC,YAAM,IAAI,gBAAAA,QAAS,MAAM,aAAa,OAAO,8BAA8B;AAAA,IAC7E;AAEA,QAAI,aAAa,KAAK;AACpB,YAAM,aAAa;AACnB,kBAAY,GAAG;AAAA,IACjB;AACA,yBAAqB,aAAa,WAAW;AAC7C,WAAO;AAAA,EACT;AACF;AA3BM,aACG,aAAa;AA4BtB,SAAS,qBAAqB,aAAmC;AAC/D,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,oBAAgB,YAAY,CAAC,CAAC;AAAA,EAChC;AACF;AAEA,IAAM,WAAN,cAAuB,gBAAAA,QAAS,WAAW;AAAA,EAGzC,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,UAAU;AAAA,EAChC;AAAA,EAEA,KAAK,UAA6B;AAEhC,QAAI,CAAC,SAAS,MAAM;AAClB,YAAM,IAAI,gBAAAA,QAAS,MAAM,gCAAgC;AAAA,IAC3D;AAEA,QAAI,SAAS,KAAK;AAChB,YAAM,SAAS;AACf,kBAAY,GAAG;AAAA,IACjB;AACA,qBAAiB,QAAQ;AACzB,WAAO;AAAA,EACT;AACF;AApBM,SACG,aAAa;AAqBtB,SAAS,iBAAiB,UAA8B;AACtD,UAAQ,SAAS,MAAM;AAAA,IACrB,KAAK;AACH,oBAAc,SAAS,WAAW;AAClC;AAAA,IACF,KAAK;AACH,yBAAmB,SAAS,WAAW;AACvC;AAAA,IACF,KAAK;AACH,yBAAmB,SAAS,WAAW;AACvC;AAAA,IACF,KAAK;AACH,8BAAwB,SAAS,WAAW;AAC5C;AAAA,IACF,KAAK;AACH,sBAAgB,SAAS,WAAW;AACpC;AAAA,IACF,KAAK;AACH,2BAAqB,SAAS,WAAW;AACzC;AAAA,IACF;AACE,YAAM,IAAI,gBAAAA,QAAS,MAAM,iCAAiC;AAAA,EAC9D;AACF;AAEA,IAAM,qBAAN,cAAiC,gBAAAA,QAAS,WAAW;AAAA,EAGnD,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,oBAAoB;AAAA,EAC1C;AAAA,EAEA,KAAK,oBAAiD;AAEpD,QAAI,OAAO,mBAAmB,eAAe,UAAU;AACrD,YAAM,IAAI,gBAAAA,QAAS,MAAM,qCAAqC;AAAA,IAChE;AAEA,QAAI,mBAAmB,KAAK;AAC1B,YAAM,mBAAmB;AACzB,kBAAY,GAAG;AAAA,IACjB;AACA,uBAAmB,mBAAmB,UAAU;AAChD,WAAO;AAAA,EACT;AACF;AApBM,mBACG,aAAa;AAqBtB,SAAS,mBAAmB,YAAkC;AAC5D,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,qBAAiB,WAAW,CAAC,CAAC;AAAA,EAChC;AACF;AAEA,IAAM,UAAN,cAAsB,gBAAAA,QAAS,WAAW;AAAA,EAGxC,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,SAAS;AAAA,EAC/B;AAAA,EAEA,KAAK,SAA2B;AAC9B,oBAAgB,OAAO;AACvB,WAAO;AAAA,EACT;AACF;AAXM,QACG,aAAa;AAYtB,SAAS,gBAAgB,SAA4B;AACnD,MAAI,CAAC,QAAQ,MAAM;AACjB,UAAM,IAAI,gBAAAA,QAAS,MAAM,0BAA0B;AAAA,EACrD;AAEA,MAAI,QAAQ,SAAS,WAAW;AAC9B,UAAM,IAAI,gBAAAA,QAAS,MAAM,QAAQ,OAAO,8BAA8B;AAAA,EACxE;AACA,MAAI,CAAC,QAAQ,UAAU;AACrB,UAAM,IAAI,gBAAAA,QAAS,MAAM,8BAA8B;AAAA,EACzD;AAEA,MAAK,QAAgB,KAAK;AACxB,UAAO,QAAgB;AACvB,gBAAY,GAAG;AAAA,EACjB;AACA,mBAAiB,QAAQ,QAAS;AACpC;AAEA,IAAM,oBAAN,cAAgC,gBAAAA,QAAS,WAAW;AAAA,EAGlD,YAAY,KAAa,SAAe;AACtC,UAAM,KAAK,SAAS,mBAAmB;AAAA,EACzC;AAAA,EAEA,KAAK,mBAA+C;AAClD,QAAI,CAAC,kBAAkB,MAAM;AAC3B,YAAM,IAAI,gBAAAA,QAAS,MAAM,oCAAoC;AAAA,IAC/D;AAEA,QAAI,kBAAkB,SAAS,qBAAqB;AAClD,YAAM,IAAI,gBAAAA,QAAS;AAAA,QACjB,kBAAkB,OAAO;AAAA,MAC3B;AAAA,IACF;AACA,QAAI,CAAC,kBAAkB,UAAU;AAC/B,YAAM,IAAI,gBAAAA,QAAS,MAAM,gDAAgD;AAAA,IAC3E;AAEA,QAAI,kBAAkB,KAAK;AACzB,YAAM,kBAAkB;AACxB,kBAAY,GAAG;AAAA,IACjB;AACA,8BAA0B,iBAAiB;AAC3C,WAAO;AAAA,EACT;AACF;AA5BM,kBACG,aAAa;AA6BtB,SAAS,0BAA0B,mBAAiE;AAClG,WAAS,IAAI,GAAG,IAAI,kBAAkB,SAAS,QAAQ,KAAK;AAC1D,oBAAgB,kBAAkB,SAAS,CAAC,CAAC;AAAA,EAC/C;AACA,SAAO;AACT;AAGC,OAAO,MAAc,UAAU;AAC/B,OAAO,MAAc,oBAAoB;AACzC,OAAO,MAAc,UAAU;AAC/B,OAAO,MAAc,WAAW;AAChC,OAAO,MAAc,qBAAqB;AAC1C,OAAO,MAAc,aAAa;AAClC,OAAO,MAAc,kBAAkB;AACvC,OAAO,MAAc,aAAa;AAClC,OAAO,MAAc,eAAe;AACpC,OAAO,MAAc,QAAQ;AAC7B,OAAO,MAAc,UAAU;AAG/B,MAAc,UAAU;AACxB,MAAc,oBAAoB;AAClC,MAAc,UAAU;AACxB,MAAc,WAAW;AACzB,MAAc,qBAAqB;AACnC,MAAc,aAAa;AAC3B,MAAc,kBAAkB;AAChC,MAAc,aAAa;AAC3B,MAAc,eAAe;AAC7B,MAAc,QAAQ;AACtB,MAAc,UAAU;","names":["mongoose","crs"]}